package signals

import (
	"encoding/gob"
	"io"
)

// Multi is a Signal generated by multiplying together Signal(s).
// multiplication scales so that, MaxLevel*MaxLevel=MaxLevel (so MaxLevel is unity).
// this makes Multi like a logic AND; all its signals (at a particular momemt) need to be MaxLevel to produce a Multi of MaxLevel.
// where as, ANY signal at zero will generate a Multi of zero.
// Multi is also a Tone, taking its period, if any, from its first member, so Multi(Tone)s need a Tone as their entry. 
type Multi []Signal

func (c Multi) Level(t Interval) (total Level) {
	total = MaxLevel
	for _, s := range c {
		l := s.Level(t)
		switch l {
		case 0:
			total = 0
			break
		case MaxLevel:
			continue
		default:
			//total = (total / HalfLevel) * (l / HalfLevel)*2
			total = (total >> HalfLevelBits) * (l >> HalfLevelBits) * 2
		}
	}
	return
}

func (c Multi) Period() (period Interval) {
	if len(c) > 0 {
		if s, ok := c[0].(Periodical); ok {
			return s.Period()
		}
	}
	return
}
func init(){
	gob.Register(Multi{})
	gob.Register(Sine{})
	gob.Register(Constant{})
	gob.Register(Pulse{})
	gob.Register(Square{})
	gob.Register(RampUp{})
	gob.Register(RampDown{})
	gob.Register(Heavyside{})
	gob.Register(Sigmoid{})
	gob.Register(Delayed{})
	gob.Register(Spedup{})
	gob.Register(SpedupProgressive{})
	gob.Register(Looped{})
	gob.Register(Inverted{})
	gob.Register(Reversed{})
	gob.Register(Reflected{})
	gob.Register(Modulated{})
	gob.Register(ADSREnvelope{})
	gob.Register(TriggerRising{})
}

func (c Multi) Save(p io.Writer) error{
	return gob.NewEncoder(p).Encode(&c)
}

func (c *Multi) Load(p io.Reader) error{
	return gob.NewDecoder(p).Decode(c)
}
