package signals

import (
	"encoding/gob"
	"io"
)

func init() {
	gob.Register(Multiplex{})
	gob.Register(Sum{})
	gob.Register(Stack{})
}

// Multiplex is a Signal generated by multiplying together Signal(s).
// multiplication scales so that, MaxLevel*MaxLevel=MaxLevel (so MaxLevel is unity).
// like logic AND; all its signals (at a particular momemt) need to be MaxLevel to produce a Multi of MaxLevel, whereas, ANY signal at zero will generate a Multi of zero.
// Multiplex is also a Periodical, taking its period, if any, from its first member.
type Multiplex []Signal

func (c Multiplex) Level(t interval) (total level) {
	total = MaxLevel
	for _, s := range c {
		l := s.Level(t)
		switch l {
		case 0:
			total = 0
			break
		case MaxLevel:
			continue
		default:
			//total = (total / HalfLevel) * (l / HalfLevel)*2
			total = (total >> HalfLevelBits) * (l >> HalfLevelBits) * 2
		}
	}
	return
}

func (c Multiplex) Period() (period interval) {
	if len(c) > 0 {
		if s, ok := c[0].(PeriodicSignal); ok {
			return s.Period()
		}
	}
	return
}

func (c Multiplex) Duration() (min interval) {
	min=-1
	for _, s := range c {
		if sls, ok := s.(limiter); ok {
			if newmin := sls.Duration(); newmin>=0 && (min==-1 || newmin < min)  {
				min = newmin
			}
		}	
	}
	return 
}
/*
// this doesn't work because Note is still a limiter (multiplex) an has durarion zero
// or TPIAW  multiplex with no limited's, results in a limited of zero duration. not good
func (c Multiplex) Duration() (min interval) {
	var found bool
	for _, s := range c {
		if sls, ok := s.(limiter); ok {
			if !found{
				min=sls.Duration()
				found=true
			}else{
				if newmin := sls.Duration(); newmin < min {
					min = newmin
				}
			}
		}	
	}
	if found {return}
	return 0
}
*/
func (c Multiplex) Save(p io.Writer) error {
	return gob.NewEncoder(p).Encode(&c)
}

func (c *Multiplex) Load(p io.Reader) error {
	return gob.NewDecoder(p).Decode(c)
}

// helper: needed becasue can't use type literal with array source.
func NewMultiplex(c ...Signal) Multiplex {
	return Multiplex(c)
}

// returns a periodical (type multiplex) based on a sine wave,
// with peak level set to MaxLevel adjusted by dB,
// dB should always be negative to remain in level limits.
func NewTone(period interval, dB float64) Multiplex {
	return Multiplex{Sine{period}, NewConstant(dB)}
}


// Sum is a Signal generated by adding together Signal(s).
// also a Periodical, taking its period, if any, from its first member.
// like 'OR' logic, all sources have to be zero (at a particular momemt) for Sum to be zero.
type Sum []Signal

func (c Sum) Level(t interval) (total level) {
	for _, s := range c {
		total += s.Level(t)
	}
	return
}

func (c Sum) Period() (period interval) {
	if len(c) > 0 {
		if s, ok := c[0].(PeriodicSignal); ok { // TODO might be better as the shortest perios?
			return s.Period()
		}
	}
	return
}

func (c Sum) Duration() (max interval) {
	max=-1
	for _, s := range c {
		if sls, ok := s.(limiter); ok {
			if newmax := sls.Duration(); newmax > max {
				max = newmax
			}
		}
	}
	return
}

func (c Sum) Save(p io.Writer) error {
	return gob.NewEncoder(p).Encode(&c)
}

func (c *Sum) Load(p io.Reader) error {
	return gob.NewDecoder(p).Decode(c)
}

// helper: needed becasue can't use type literal with array source.
func NewSum(c ...Signal)  Sum {
	return Sum(c)
}

// Stack is a Signal generated by adding together Signal(s).
// source Signals are scaled down by Stacks count, making it impossible to overrun maxlevel.
// also a Periodical, taking its period, if any, from its first member.
// like 'OR' logic, all sources have to be zero (at a particular momemt) for Stack to be zero.
type Stack []Signal

func (c Stack) Level(t interval) (total level) {
	for _, s := range c {
		total += s.Level(t) / level(len(c))
	}
	return
}

func (c Stack) Period() (period interval) {
	if len(c) > 0 {
		if s, ok := c[0].(PeriodicSignal); ok { // TODO might be better as the shortest perios?
			return s.Period()
		}
	}
	return
}

func (c Stack) Duration() (max interval) {
	max=-1
	for _, s := range c {
		if sls, ok := s.(limiter); ok {
			if newmax := sls.Duration(); newmax > max {
				max = newmax
			}
		}
	}
	return
}

func (c Stack) Save(p io.Writer) error {
	return gob.NewEncoder(p).Encode(&c)
}

func (c *Stack) Load(p io.Reader) error {
	return gob.NewDecoder(p).Decode(c)
}

// helper: needed becasue can't use type literal with array source.
func NewStack(c ...Signal) Stack {
	return Stack(c)
}

