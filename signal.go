/*
Package signals generates and manipulates signals.

signals here are as:- "https://en.wikipedia.org/wiki/Signal_processing",
where they "convey information about the behaviour or attributes of some phenomenon",
more specifically here:- "any quantity exhibiting variation in time or variation in space".

currently this package supports only 1-Dimensionsal variation.

for simplicity terminolology used represents analogue variation in time.

intended to be general, a base package for import, and used then with specific real-world quantities.
*/
package signals

import (
	"fmt"
	"math"
	"time"
)

// signal types can represent an analogue level as it varies with time
type Signal interface {
	Level(Interval) Level
}

// Interval is considered to be a time duration from -infinity to +infinity.
// Intervals here can be generated from time.Duration, signals.Interval(time.Duration).
// encoded as a time.Duration, which is encoded as an int64, giving actually a range of 290 years at nanosecond resolution.
// Levels at -ve intervals are considered imaginary, and not used, unless a Delay makes them +ve.
type Interval time.Duration

func (i Interval) String() string {
	return fmt.Sprintf("%9.2fs", float32(i)/float32(UnitTime))
}

const UnitTime = Interval(time.Second)

// the Level type is a value between +MaxLevel and -MaxLevel.
type Level int64

const MaxLevel Level = math.MaxInt64
const LevelBits = 64
const HalfLevelBits = LevelBits / 2

//const HalfLevel=2<<(HalfLevelBits-1)

// float64 has less resolution than int64 at maxlevel, so need this to scale float64 sourced signals to never overflow int64
const MaxLevelfloat64 float64 = float64(MaxLevel - 512)

// formatted representation of a level as percentage.
func (l Level) String() string {
	return fmt.Sprintf("%9.2f%%", 100*float32(l)/float32(MaxLevel))
}

// Multi is a Signal generated by multiplying together multiple Signal(s)
// multiplication scales so that, MaxLevel*MaxLevel=MaxLevel (so MaxLevel is unity).
// this makes Multi like a logic AND; all its signals (at a particular momemt) need to be MaxLevel to produce a Multi of MaxLevel.
// where as, ANY sognal at zero will generate a Multi of zero.
type Multi []Signal

func (c Multi) Level(t Interval) (total Level) {
	total = MaxLevel
	for _, s := range c {
		l := s.Level(t)
		switch l {
		case 0:
			total = 0
			break
		case MaxLevel:
			continue
		default:
			//total = (total / HalfLevel) * (l / HalfLevel)*2
			total = (total >> HalfLevelBits) * (l >> HalfLevelBits) * 2
		}
	}
	return
}

func (c Multi) Period() (period Interval) {
	if len(c) > 0 {
		if tone, ok := c[0].(Tone); ok {
			return tone.Period()
		}
	}
	return
}
