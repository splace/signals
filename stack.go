package signals

import (
	"encoding/gob"
	"io"
)

func init() {
	gob.Register(Stack{})
	gob.Register(Sum{})
}

// Stack is a Signal generated by adding together Signal(s).
// source Signals are scaled down by Stacks count, making it impossible to overrun maxlevel.
// also a Periodical, taking its period, if any, from its first member.
// like 'OR' logic, all sources have to be zero (at a particular momemt) for Stack to be zero.
type Stack []Signal

func (c Stack) Level(t interval) (total level) {
	for _, s := range c {
		total += s.Level(t)/level(len(c))
	}
	return
}

func (c Stack) Period() (period interval) {
	if len(c) > 0 {
		if s, ok := c[0].(Periodical); ok { // TODO might be better as the shortest perios?
			return s.Period()
		}
	}
	return
}

func (c Stack) Duration() (max interval) {
	for _, s := range c {
		if sls, ok := s.(LimitedSignal); ok { 
			if newmax:=sls.Duration();newmax>max{
				max=newmax
			}
		}
	}
	return
}

func (c Stack) Save(p io.Writer) error {
	return gob.NewEncoder(p).Encode(&c)
}

func (c *Stack) Load(p io.Reader) error {
	return gob.NewDecoder(p).Decode(c)
}
// helper: needed becasue can't use type literal with array source. 
func NewStack(c ...Signal) Stack{
	return Stack(c)
}


// Sum is a Stack that doesn't scale its contents, so can overflow.
type Sum struct{
	Stack
	}
	
func (c Sum) Level(t interval) (total level) {
	for _, s := range c.Stack {
		total += s.Level(t)
	}
	return
}

// helper: needed becasue can't use type literal with array source drectly. 
func NewSum(c ...Signal) Sum{
	return Sum{Stack(c)}
}



